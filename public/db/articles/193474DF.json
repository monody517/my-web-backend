{"id":"193474DF","hash":"sha256nicedata:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCABkAMgDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//Zhex","title":"深入this指向","content":"我们知道，this代表的是函数的指向。那么我们也同时需要明白一个问题就是，函数的this，是在什么时间确认的。\n\n前面我们学习执行上下文的过程中，有提到关于this的信息，在执行上下文的环境记录对象中，存在一个内部属性[[ThisValue]]用于记录this指向，同时还存在一个内部方法BindThisValue用于设置[[ThisValue]]的值。这也就是说，this的指向，对于函数来说是在执行上下文的创建过程中确定的。因此，这也是为什么说，this的指向是在函数调用的时候才确定的。\n\n```js\nconst a = 20\n\nconst obj = {\n    a: 20\n}\n\nfunction fn(){\n    console.log(this.a)\n}\n\nfn() // 10\nfn.call(obj) // 20\n```\n\n通过a的值的不同体现，我们知道this分别指向window对象和obj对象。\n\n## 全局上下文中的this\n\n在全局上下文中，this对象指向全局对象本身\n\n```js\nthis.a = 20\n\nvar b = 10\n\nc = 30\n\nconst d = 40 // const,let声明的不会挂载在全局对象上\n\nconsole.log(a) // 20\nconsole.log(b) // 10\nconsole.log(c) // 30\nconsole.log(d) // undefined\n```\n\n## 函数中的this\n\n函数上下文中的this，和调用该函数的方式息息相关。\n\n在一个函数执行上下文中，this由该函数的调用者caller提供，由调用的方式决定。\n- 有明确的调用者\n- 独立调用，无明确调用者\n\n```js\nfunction fn(a){\n    console.log(arguments.callee)\n    console.log(this)\n}\n\nwindow.fn(10)\n```\n\n很显然当前window是调用者callee，fn是被调用者caller，因此fn内部的this指向window。但同时还有一种写法：\n\n```js\nfunction fn(a){\n    console.log(arguments.callee)\n    console.log(this)\n}\n\nfn(10)\n```\n\n此时需要分情况来讨论，在严格模式下，fn此时没有调用者，因此this指向undefined，正在非严格模式下，fn的this依然默认由window来承担。\n\n## call/apply/bind显示指定this\n\njs提供了call/apply/bind方法显示的设置this的指向，所有函数均可以调用此方法。\n\n```js\nvar a = 20\n\nvar object = {\n    a: 40\n}\n\nfunction fn() {\n    console.log(this.a)\n} \n```\n\n如果我们正常独立直接调用fn，在非严格模式下this会指向window对象，因此函数输出20，但我们还可以通过显示指定的方法设置fn的调用者。\n\n```js\nfn.call(object) // 40\nfn.apply(object) // 40\n```\n\n在调用call/apply时，实际上还是执行fn本身，只是将函数中的this指向设置为传入的第一个参数，它们的区别就是参数传递方式不同。\n\ncall的第一个参数是函数内部指定的this指向，后续参数是函数本身执行需要的参数，一个一个进行传递，\n\napply的第一个参数和call一样，而第二个参数则是函数本身需要的全部参数，整合为一个数组进行传递。\n\n```js\nfunction fn(a,b){\n    return this.g + a + b\n}\n\nvar g = 1\nvar object = {g: 2}\n\nfn(10,10) // 21\n\nfn.call(object,10,10) // 22\nfn,apply(object,[10,10]) // 22\n```\n\nbind方法也能显示指定函数内部this指向，但是它和call/apply仍有不同。\n\n当函数调用bind时，函数不会立即执行，而是返回一个新的函数，这个函数和原函数一样，但是并非原函数，新函数的this指向已经被绑定，参数为bind的后续参数。\n\n```js\nfunction fn(a,b){\n     return this.g + a + b\n}\n\nvar g = 1\nvar object = {g: 2}\n\nvar _fn = fn.bind(object,1,1)\n\nconsole.log(_fn === fn) //false\n_fn() // 4\n_fn(2,2) // 6\n```\n\n\n","type":1}